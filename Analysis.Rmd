```{r}
library(arrow)
library(caret)
library(dplyr)
library(forecast)
library(ggmap)
library(ggplot2)
library(glue)
library(imputeTS)
library(jsonlite)
library(lubridate)
library(quanteda)
library(quanteda.textplots)
library(quanteda.textstats)
library(RCurl)
library(readr)
library(rmarkdown)
library(shiny)
library(tidyverse)
library(data.table)
library(janitor)
library(readxl)
library(writexl)
library(corrplot)
library(randomForest)
library(ranger)
```

```{r}
data <- read_parquet("/Users/surabhiarchitha/Downloads/merged_energy_weather_july_with_county.parquet")
```

```{r}
colSums(is.na(data))
zero_check <- colSums(data == 0) / nrow(data) * 100
zero_check
```

```{r}
zero_cols <- colnames(data)[colSums(data == 0) / nrow(data) == 1]
data <- data[, !colnames(data) %in% zero_cols]
```


```{r}
# Step 1: Ensure 'time' column is in datetime format
data <- data %>%
  mutate(
    time = as.character(time),                     # Ensure 'time' is a character column
    time_parsed = ymd_hms(time, quiet = TRUE),     # Attempt to parse as datetime
    invalid_time_flag = is.na(time_parsed)         # Flag rows where parsing failed
  )

data <- data %>%
  mutate(
    time_parsed = if_else(
      invalid_time_flag, 
      ymd_hms("2018-07-01 00:00:00"),  # Replace with a default value (e.g., midnight on July 1)
      time_parsed
    )
  )

data <- data %>%
  mutate(
    date = as.Date(time_parsed),               # Extract the date
    time_stamp = format(time_parsed, "%H:%M:%S") # Extract the time
  )

# Step 3: Categorize 'time_stamp' into 'morning', 'noon/evening', and 'night'
data <- data %>%
  mutate(
    hour_of_day = hour(time_parsed), # Extract hour
    period_of_day = case_when(
      hour_of_day >= 6 & hour_of_day < 12 ~ "morning",
      hour_of_day >= 12 & hour_of_day < 18 ~ "noon/evening",
      TRUE ~ "night"
    )
  ) %>%
  select(-hour_of_day, -time, -time_parsed,-invalid_time_flag) 

# Drop intermediate 'hour_of_day' column
```

```{r}
write.csv(data, "cleaned_energy_weather_data_with_imputation.csv", row.names = FALSE)
```


```{r}
data_grouped <- data %>%
  group_by(building_id, date, period_of_day) %>%
  summarise(
    # Sum energy consumption columns
    across(
      contains("energy_consumption"), 
      sum, na.rm = TRUE, 
      .names = "sum_{.col}"
    ),
    # Average weather columns
    across(
      c(
        "Dry Bulb Temperature [°C]",
        "Relative Humidity [%]",
        "Wind Speed [m/s]",
        "Wind Direction [Deg]",
        "Global Horizontal Radiation [W/m2]",
        "Direct Normal Radiation [W/m2]",
        "Diffuse Horizontal Radiation [W/m2]"
      ),
      mean, na.rm = TRUE,
      .names = "avg_{.col}"
    ),
    .groups = "drop"  # Drop grouping after summarization
  )
```

```{r}
write.csv(data_grouped, "grouped_energy_data.csv", row.names = FALSE)
```

```{r}
grouped_data <- read_csv("/Users/surabhiarchitha/grouped_energy_data.csv")
```

```{r}
# Calculate Total Energy Usage
energy_columns <- grep("energy_consumption", names(grouped_data), value = TRUE)
grouped_data <- grouped_data %>%
  mutate(Total_Energy_Usage = rowSums(select(., all_of(energy_columns)), na.rm = TRUE))
```

```{r}
grouped_data$date <- as.Date(grouped_data$date)
```

```{r}
colnames(grouped_data)
```

```{r}
# Group by 'building_id' and 'date', summing total energy consumption
grouped_data1 <- grouped_data %>%
  group_by(building_id, date) %>%
  summarise(
    Total_Energy_Usage = sum(Total_Energy_Usage, na.rm = TRUE),
    avg_Dry_Bulb_Temperature_C = mean(avg_Dry_Bulb_Temperature_C, na.rm = TRUE),
    avg_Relative_Humidity = mean(`avg_Relative_Humidity_%`, na.rm = TRUE),
    avg_Wind_Speed = mean(`avg_Wind_Speed_m/s`, na.rm = TRUE),
    avg_Wind_Direction = mean(avg_Wind_Direction_Deg, na.rm = TRUE),
    avg_Global_Horizontal_Radiation = mean(`avg_Global_Horizontal_Radiation_W/m2`, na.rm = TRUE),
    avg_Direct_Normal_Radiation = mean(`avg_Direct_Normal_Radiation_W/m2`, na.rm = TRUE),
    avg_Diffuse_Horizontal_Radiation = mean(`avg_Diffuse_Horizontal_Radiation_W/m2`, na.rm = TRUE),
    .groups = "drop"
  )
```

```{r}
write.csv(grouped_data1, "grouped_energy_data1.csv", row.names = FALSE)
```

```{r}
grouped_data1 <- read_csv("/Users/surabhiarchitha/Documents/4th sem/IDS/Project/grouped_energy_data1.csv")
```


```{r}
# Handle outliers
grouped_data1 <- grouped_data1 %>%
  filter(Total_Energy_Usage > 0)  # Remove negative or zero values
```

```{r}
summary(grouped_data1$Total_Energy_Usage)
```

```{r}
# Descriptive Analysis
# Summary of numerical variables
summary(select_if(grouped_data1, is.numeric))
```

```{r}
# Count unique values and inspect categorical variables
sapply(select_if(grouped_data1, is.character), function(x) length(unique(x)))

# Check for missing values
missing_values <- colSums(is.na(grouped_data1))
missing_values <- missing_values[missing_values > 0]
print(missing_values)
```

```{r}
colSums(is.na(grouped_data1))
```

```{r}
# Energy Consumption Trends
# Summarize total energy consumption by period of day
energy_trends <- grouped_data %>%
  group_by(period_of_day) %>%
  summarize(total_energy = sum(Total_Energy_Usage, na.rm = TRUE))
energy_trends
```

```{r}
# Plot energy consumption trends
ggplot(energy_trends, aes(x = period_of_day, y = total_energy, fill = period_of_day)) +
  geom_bar(stat = "identity") +
  labs(title = "Total Energy Consumption by Period of Day", x = "Period of Day", y = "Total Energy Consumption") +
  theme_minimal()
```

```{r}
# Correlations with Environmental Factors
# Select numeric columns including total energy and environmental factors
numeric_cols <- grouped_data1 %>%
  select(Total_Energy_Usage, starts_with("avg_"))
# Compute correlation matrix
cor_matrix <- cor(numeric_cols, use = "complete.obs")
# Plot correlation matrix
corrplot(cor_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 45)
```

```{r}
# High-Usage Devices
# Calculate average consumption for each device
device_consumption <- grouped_data %>%
  select(starts_with("sum_out.electricity")) %>%
  summarise(across(everything(), mean, na.rm = TRUE)) %>%
  pivot_longer(everything(), names_to = "device", values_to = "average_consumption")

# Identify the top 5 high-usage devices
top_devices <- device_consumption %>%
  arrange(desc(average_consumption)) %>%
  slice(1:5)
```

```{r}
# Plot top devices
ggplot(top_devices, aes(x = reorder(device, -average_consumption), y = average_consumption, fill = device)) +
  geom_bar(stat = "identity") +
  labs(title = "Top 5 High-Energy Usage Devices", x = "Device", y = "Average Energy Consumption") +
  theme_minimal() +
  coord_flip()
```

```{r}
# Scatter plot for temperature vs Total Energy Usage
ggplot(grouped_data1, aes(x = `avg_Dry_Bulb_Temperature_C`, y = Total_Energy_Usage)) +
  geom_point(alpha = 0.5) +
  labs(title = "Temperature vs Total Energy Usage", x = "Temperature (°C)", y = "Total Energy Usage")
```

```{r}
# Group temperature into bins and calculate mean energy usage
grouped_data1 %>%
  mutate(temp_bin = cut(`avg_Dry_Bulb_Temperature_C`, breaks = seq(20, 45, 5))) %>%
  group_by(temp_bin) %>%
  summarize(mean_energy_usage = mean(Total_Energy_Usage, na.rm = TRUE)) %>%
  ggplot(aes(x = temp_bin, y = mean_energy_usage, fill = temp_bin)) +
  geom_col() +
  labs(title = "Average Energy Usage by Temperature Range",
       x = "Temperature Range (°C)", y = "Average Energy Usage") +
  theme_minimal()

```
```{r}
#trends in specific energy usage over time
# Convert date column to Date format
grouped_data$date <- as.Date(grouped_data$date)

# Define columns for specific energy usage
energy_trend_columns <- c(
  "sum_out.electricity.cooling.energy_consumption",
  "sum_out.electricity.heating.energy_consumption",
  "sum_out.electricity.lighting_interior.energy_consumption",
  "sum_out.electricity.plug_loads.energy_consumption",
  "sum_out.electricity.refrigerator.energy_consumption"
)

# Aggregate data by date for trend analysis
trend_data <-grouped_data %>%
  group_by(date) %>%
  summarise(across(all_of(energy_trend_columns), sum, na.rm = TRUE))

# Convert data to long format for ggplot
trend_data_long <- trend_data %>%
  pivot_longer(cols = all_of(energy_trend_columns), 
               names_to = "Energy_Usage", 
               values_to = "Consumption")

# Clean up column names for better visualization
trend_data_long$Energy_Usage <- trend_data_long$Energy_Usage %>%
  str_replace_all("sum_out.electricity.", "") %>%
  str_replace_all(".energy_consumption", "") %>%
  str_replace_all("_", " ") %>%
  str_to_title()

# Plot trends
ggplot(trend_data_long, aes(x = date, y = Consumption, color = Energy_Usage)) +
  geom_line(linewidth = 1) +
  labs(
    title = "Trends in Specific Energy Usage Over Time",
    x = "Date",
    y = "Energy Consumption (kWh)",
    color = "Energy Usage"
  ) +
  theme_minimal()
```



```{r}
# Energy Usage Analysis
# Plot distribution of Total Energy Usage
ggplot(grouped_data1, aes(x = Total_Energy_Usage)) + 
  geom_histogram(bins = 30, fill = "blue", color = "white") +
  labs(title = "Total Energy Usage Distribution", x = "Total Energy Usage", y = "Count")
```

```{r}
# Weather Impact Analysis
# Correlation matrix for numerical variables
num_data <- select_if(grouped_data1, is.numeric)
cor_matrix <- cor(num_data, use = "complete.obs")

# Convert correlation matrix to a long format
cor_melted <- as.data.frame(as.table(cor_matrix))

# Plot heatmap with ggplot2
ggplot(cor_melted, aes(Var1, Var2, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab",
                       name = "Correlation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8)) +
  labs(title = "Correlation Heatmap", x = "Variables", y = "Variables")
```
```{r}
model <- lm(Total_Energy_Usage ~ avg_Dry_Bulb_Temperature_C, data = grouped_data1)
summary(model)
plot(grouped_data1$avg_Dry_Bulb_Temperature_C, grouped_data1$Total_Energy_Usage, 
     main = "Temperature vs Total Energy Usage",
     xlab = "Temperature (°C)", 
     ylab = "Total Energy Usage",
     pch = 19, col = "blue")
abline(model, col = "red", lwd = 2)
```


```{r}
install.packages("xgboost")
library(xgboost)

# Split data into training and testing sets
train_index <- createDataPartition(grouped_data1$Total_Energy_Usage, p= 0.8, list = FALSE)
train_data <- grouped_data1[train_index, ]
test_data <- grouped_data1[-train_index, ]
                                   
                                   
# Define predictors and target
predictors <- c("avg_Dry_Bulb_Temperature_C", "avg_Relative_Humidity", 
                "avg_Wind_Speed", "avg_Global_Horizontal_Radiation", 
                "avg_Direct_Normal_Radiation", "avg_Diffuse_Horizontal_Radiation")
target <- "Total_Energy_Usage"

# Model 1: Linear Regression
linear_model <- lm(Total_Energy_Usage ~ ., data = train_data[, c(predictors, target)])
linear_predictions <- predict(linear_model, test_data[, predictors])
linear_r2 <- R2(linear_predictions, test_data$Total_Energy_Usage)
linear_rmse <- sqrt(mean((linear_predictions - test_data$Total_Energy_Usage)^2))
cat("Linear Regression RMSE:", linear_rmse, "\n")

# Model 2: Random Forest
rf_model <- randomForest(Total_Energy_Usage ~ ., data = train_data[, c(predictors, target)], ntree = 100)
rf_predictions <- predict(rf_model, test_data[, predictors])
rf_r2 <- R2(rf_predictions, test_data$Total_Energy_Usage)
rf_rmse <- sqrt(mean((rf_predictions - test_data$Total_Energy_Usage)^2))
cat("Random Forest RMSE:", rf_rmse, "\n")

# Model 3: XGBoost
xgb_train <- xgb.DMatrix(data = as.matrix(train_data[, predictors]), label = train_data$Total_Energy_Usage)
xgb_test <- xgb.DMatrix(data = as.matrix(test_data[, predictors]))
xgb_model <- xgboost(data = xgb_train, nrounds = 100, objective = "reg:squarederror", verbose = FALSE)
xgb_predictions <- predict(xgb_model, xgb_test)
xgb_r2 <- R2(xgb_predictions, test_data$Total_Energy_Usage)
xgb_rmse <- sqrt(mean((xgb_predictions - test_data$Total_Energy_Usage)^2))
cat("XGBoost RMSE:", xgb_rmse, "\n")

# Compare models
rmse_values <- c(Linear = linear_rmse, RandomForest = rf_rmse, XGBoost = xgb_rmse)
best_model <- names(rmse_values)[which.min(rmse_values)]
cat("Best Model:", best_model, "with RMSE =", min(rmse_values), "\n")

# Compile results into a data frame
results <- data.frame(
  Model = c("Linear Regression", "Random Forest", "XGBoost"),
  R2 = c(linear_r2, rf_r2, xgb_r2),
  RMSE = c(linear_rmse, rf_rmse, xgb_rmse))
```

```{r}
# Combine results for visualization
results1 <- data.frame(
  Actual = test_data$Total_Energy_Usage,
  Linear = linear_predictions,
  RandomForest = rf_predictions,
  XGBoost = xgb_predictions
)


# Plot Linear Regression
ggplot(results1, aes(x = Actual, y = Linear)) +
  geom_point(alpha = 0.5, color = "blue") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  labs(title = "Linear Regression: Actual vs Predicted",
       x = "Actual Total Energy Usage",
       y = "Predicted Total Energy Usage") +
  theme_minimal()

# Plot Random Forest
ggplot(results1, aes(x = Actual, y = RandomForest)) +
  geom_point(alpha = 0.5, color = "orange") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  labs(title = "Random Forest: Actual vs Predicted",
       x = "Actual Total Energy Usage",
       y = "Predicted Total Energy Usage") +
  theme_minimal()

# Plot XGBoost
ggplot(results1, aes(x = Actual, y = XGBoost)) +
  geom_point(alpha = 0.5, color = "green") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  labs(title = "XGBoost: Actual vs Predicted",
       x = "Actual Total Energy Usage",
       y = "Predicted Total Energy Usage") +
  theme_minimal()
```

```{r}
#Feature engineering and selection
# Calculate correlation matrix
cor_matrix <- cor(grouped_data1[, predictors])
print(cor_matrix)

# Recursive Feature Elimination
library(caret)
control <- rfeControl(functions = rfFuncs, method = "cv", number = 5)
rfe_results <- rfe(train_data[, predictors], train_data$Total_Energy_Usage, 
                   sizes = c(1:6), rfeControl = control)
```

```{r}
#hyperparameter optimization
# Tune Random Forest
rf_grid <- expand.grid(mtry = c(2, 4, 6))
control <- trainControl(method = "cv", number = 5)
rf_tuned <- train(Total_Energy_Usage ~ ., data = train_data, method = "rf", 
                  trControl = control, tuneGrid = rf_grid, ntree = 500)


# Tune XGBoost
xgb_grid <- expand.grid(
  nrounds = c(100, 200),            # Number of boosting rounds
  max_depth = c(3, 6, 9),           # Maximum depth of trees
  eta = c(0.01, 0.1, 0.3),          # Learning rate
  gamma = c(0, 1),                  # Minimum loss reduction
  colsample_bytree = c(0.5, 0.8),   # Fraction of features used per tree
  subsample = c(0.8, 1),            # Fraction of samples used per tree
  min_child_weight = c(1, 5)        # Minimum sum of instance weight (hessian) needed in a child
)

# Train the XGBoost model using cross-validation
xgb_tuned <- train(
  Total_Energy_Usage ~ ., data = train_data, method = "xgbTree",
  trControl = trainControl(method = "cv", number = 5), tuneGrid = xgb_grid
)
```


```{r}
install.packages("keras")
library(keras)

# Prepare data
X_train_scaled <- scale(train_data[, predictors])
X_test_scaled <- scale(test_data[, predictors])

# Build Neural Network
model <- keras_model_sequential() %>%
  layer_dense(units = 64, activation = "relu", input_shape = ncol(X_train_scaled)) %>%
  layer_dense(units = 32, activation = "relu") %>%
  layer_dense(units = 1, activation = "linear")

# Compile model
model %>% compile(
  optimizer = optimizer_adam(learning_rate = 0.001),
  loss = "mse",
  metrics = c("mae")
)

# Train model
history <- model %>% fit(
  X_train_scaled, train_data$Total_Energy_Usage,
  epochs = 50, batch_size = 32, validation_split = 0.2
)

# Evaluate model
model %>% evaluate(X_test_scaled, test_data$Total_Energy_Usage)
```




















```{r}
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(grouped_data$Total_Energy_Usage, p= 0.8, list = FALSE)
train_data <- grouped_data[train_index, ]
test_data <- grouped_data[-train_index, ]
                                   
                                   
# Define predictors and target
predictors <- c("avg_Dry_Bulb_Temperature_C", `avg_Relative_Humidity_%`, 
                `avg_Wind_Speed_m/s`, `avg_Global_Horizontal_Radiation_W/m2`, 
                `avg_Direct_Normal_Radiation_W/m2`, `avg_Diffuse_Horizontal_Radiation_W/m2`,"period_of_day")
target <- "Total_Energy_Usage"

# Model 1: Linear Regression
linear_model <- lm(Total_Energy_Usage ~ ., data = train_data[, c(predictors, target)])
linear_predictions <- predict(linear_model, test_data[, predictors])
linear_r2 <- R2(linear_predictions, test_data$Total_Energy_Usage)
linear_rmse <- sqrt(mean((linear_predictions - test_data$Total_Energy_Usage)^2))
cat("Linear Regression RMSE:", linear_rmse, "\n")

# Model 2: Random Forest
rf_model <- randomForest(Total_Energy_Usage ~ ., data = train_data[, c(predictors, target)], ntree = 100)
rf_predictions <- predict(rf_model, test_data[, predictors])
rf_r2 <- R2(rf_predictions, test_data$Total_Energy_Usage)
rf_rmse <- sqrt(mean((rf_predictions - test_data$Total_Energy_Usage)^2))
cat("Random Forest RMSE:", rf_rmse, "\n")

# Model 3: XGBoost
xgb_train <- xgb.DMatrix(data = as.matrix(train_data[, predictors]), label = train_data$Total_Energy_Usage)
xgb_test <- xgb.DMatrix(data = as.matrix(test_data[, predictors]))
xgb_model <- xgboost(data = xgb_train, nrounds = 100, objective = "reg:squarederror", verbose = FALSE)
xgb_predictions <- predict(xgb_model, xgb_test)
xgb_r2 <- R2(xgb_predictions, test_data$Total_Energy_Usage)
xgb_rmse <- sqrt(mean((xgb_predictions - test_data$Total_Energy_Usage)^2))
cat("XGBoost RMSE:", xgb_rmse, "\n")

# Compare models
rmse_values <- c(Linear = linear_rmse, RandomForest = rf_rmse, XGBoost = xgb_rmse)
best_model <- names(rmse_values)[which.min(rmse_values)]
cat("Best Model:", best_model, "with RMSE =", min(rmse_values), "\n")

# Compile results into a data frame
results <- data.frame(
  Model = c("Linear Regression", "Random Forest", "XGBoost"),
  R2 = c(linear_r2, rf_r2, xgb_r2),
  RMSE = c(linear_rmse, rf_rmse, xgb_rmse))
```





















